<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Workout Tracker Test Page</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    /* Custom Styles */
    .tag {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 500;
      border-radius: 9999px;
    }
    .tag-arms { background-color: #dbeafe; color: #1e40af; }
    .tag-back { background-color: #dcfce7; color: #166534; }
    .tag-shoulders { background-color: #fef3c7; color: #92400e; }
    .tag-legs { background-color: #ede9fe; color: #5b21b6; }
    .tag-other { background-color: #f3f4f6; color: #1f2937; }

    .btn {
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      font-weight: 500;
      color: white;
      transition: background-color 0.2s;
    }
    .btn-primary {
      background-color: #2563eb;
    }
    .btn-primary:hover {
      background-color: #1d4ed8;
    }
    .btn-success {
      background-color: #16a34a;
    }
    .btn-success:hover {
      background-color: #15803d;
    }
    .input {
      padding: 0.5rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
    }
    .input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
    }
    .type-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.25rem;
      max-width: 180px;
      margin-right: 0.5rem;
    }
    .rotate-180 {
      transform: rotate(180deg);
    }
    .transition-transform {
      transition-property: transform;
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
      transition-duration: 200ms;
    }
    .ml-auto {
      margin-left: auto;
    }
    .border-t {
      border-top-width: 1px;
    }
    .border {
      border-width: 1px;
    }
    .border-gray-200 {
      border-color: #e5e7eb;
    }
    .rounded-md {
      border-radius: 0.375rem;
    }
    .truncate {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .flex {
      display: flex;
    }
    .flex-col {
      flex-direction: column;
    }
    .items-center {
      align-items: center;
    }
    .text-center {
      text-align: center;
    }
    .w-full {
      width: 100%;
    }
    .gap-1 {
      gap: 0.25rem;
    }
    .text-base {
      font-size: 1rem;
    }
    .mb-0.5 {
      margin-bottom: 0.125rem;
    }
    @media (max-width: 640px) {
      .type-grid {
        max-width: 150px;
      }
    }
  </style>
</head>
<body class="bg-gray-100">
  <div id="app" class="min-h-screen p-4 md:p-6 max-w-4xl mx-auto">
    <header class="mb-6">
      <h1 class="text-2xl font-bold text-center text-blue-600">Workout Tracker (Test Page)</h1>
    </header>

    <div class="bg-white rounded-lg shadow p-4">
      <div class="mb-4">
        <div class="flex items-center flex-grow">
          <input 
            v-model="newWorkoutName" 
            @keyup.enter="addWorkout"
            placeholder="Add new workout..." 
            class="input flex-grow mr-2" 
            type="text"
          />
          <div class="type-grid">
            <button 
              v-for="type in workoutTypes" 
              :key="type" 
              @click="newWorkoutType = type" 
              :class="['px-2 py-1.5 text-xs rounded border flex flex-col items-center', newWorkoutType === type ? 'bg-blue-100 border-blue-500' : 'bg-gray-100 border-gray-300']"
              type="button"
            >
              <span class="text-base mb-0.5">{{ typeEmojis[type] }}</span>
              <span class="truncate w-full text-center">{{ type }}</span>
            </button>
          </div>
          <button type="button" @click="addWorkout" class="btn btn-primary">Add</button>
        </div>
        
      </div>

      <div v-if="workouts.length > 0" class="mb-4 border border-gray-200 rounded-md">
        <button 
          @click="showFilters = !showFilters" 
          class="w-full px-4 py-2 text-left flex justify-between items-center bg-gray-50 hover:bg-gray-100"
        >
          <span class="font-medium">Filters & Sorting</span>
          <span class="text-sm text-gray-500">
            {{ filterType ? `Type: ${filterType}` : 'All types' }} | 
            {{ getSortLabel(sortOption) }}
          </span>
          <svg 
            class="w-5 h-5 transform transition-transform" 
            :class="{ 'rotate-180': showFilters }"
            fill="none" 
            stroke="currentColor" 
            viewBox="0 0 24 24"
          >
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
          </svg>
        </button>

        <div v-if="showFilters" class="p-4 border-t border-gray-200">
          <div class="flex flex-wrap gap-2 mb-3">
            <span class="text-sm font-medium">Filter by type:</span>
            <button
              @click="filterType = ''"
              :class="['px-2 py-1 text-xs rounded border', filterType === '' ? 'bg-blue-100 border-blue-500' : 'bg-gray-100 border-gray-300']"
              type="button"
            >
              All
            </button>
            <button
              v-for="type in usedWorkoutTypes"
              :key="type"
              @click="filterType = type"
              :class="['px-2 py-1.5 text-xs rounded border flex flex-col items-center', filterType === type ? 'bg-blue-100 border-blue-500' : 'bg-gray-100 border-gray-300']"
              type="button"
            >
              <span class="text-base mb-0.5">{{ typeEmojis[type] }}</span>
              <span class="truncate w-full text-center">{{ type }}</span>
            </button>
          </div>
          
          <div class="flex flex-wrap gap-2 items-center">
            <span class="text-sm font-medium">Sort by:</span>
            <select v-model="sortOption" class="input text-sm" style="max-width: 150px">
              <option value="alphabetical">Alphabetical</option>
              <option value="type">By Type</option>
              <option value="recent">Most Recent</option>
              <option value="oldest">Oldest First</option>
            </select>
            <button @click="resetFilters" class="ml-auto text-sm text-blue-500 hover:text-blue-700">
              Reset Filters
            </button>
          </div>
        </div>
      </div>

      <div v-if="filteredWorkouts.length === 0" class="text-center text-gray-500 py-6">
        No workouts added yet. Add your first workout above!
      </div>

      <div v-else class="overflow-x-auto">
        <table class="min-w-full">
          <thead>
            <tr class="bg-gray-50 border-b">
              <th class="text-left py-3 px-4">Workout</th>
              <th class="text-left py-3 px-4">Type</th>
              <th class="text-left py-3 px-4">Last Weight</th>
              <th class="text-left py-3 px-4">Last Worked Out</th>
              <th class="text-center py-3 px-4">Actions</th>
              <th class="text-center py-3 px-4">Remove</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="(workout, index) in filteredWorkouts" 
                :key="workout.id" 
                class="border-b hover:bg-gray-50 transition-colors">
              <td class="py-3 px-4">{{ workout.name }}</td>
              <td class="py-3 px-4 text-sm">
                <span :class="['tag flex items-center gap-1', `tag-${workout.type.toLowerCase()}`]">
                  <span>{{ typeEmojis[workout.type] }}</span>
                  <span class="truncate">{{ workout.type }}</span>
                </span>
              </td>
              <td class="py-3 px-4">
                <input 
                  v-model="workout.weight" 
                  type="text" 
                  class="input w-full max-w-[120px]" 
                  placeholder="Weight"
                  @change="saveWorkouts"
                />
              </td>
              <td class="py-3 px-4">
                {{ workout.lastDate ? formatDate(workout.lastDate) : 'Never' }}
              </td>
              <td class="py-3 px-4 text-center">
                <button 
                  @click="markWorkoutDone(index)" 
                  class="btn btn-success text-sm py-1 px-3">
                  Done Today
                </button>
              </td>
              <td class="py-3 px-4 text-center">
                <button 
                  @click="removeWorkout(index)" 
                  class="text-red-500 hover:text-red-700 transition-colors">
                  ✕
                </button>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="mt-4 p-4 bg-white rounded-lg shadow">
      <h2 class="text-lg font-semibold mb-2">Debug Info</h2>
      <pre class="bg-gray-100 p-2 rounded text-xs overflow-auto" style="max-height: 200px">{{ debugInfo }}</pre>
    </div>
  </div>

  <script>
    const app = {
      data() {
        return {
          workouts: [],
          newWorkoutName: '',
          newWorkoutType: 'Arms',
          workoutTypes: ['Arms', 'Legs', 'Back', 'Shoulders', 'Other'],
          typeEmojis: {
            Arms: '💪',
            Back: '🔙',
            Shoulders: '🍖',
            Legs: '🦵',
            Other: '🤷'
          },
          filterType: '',
          sortOption: 'alphabetical',
          showFilters: false,
          debugInfo: 'App initialized'
        }
      },
      mounted() {
        this.loadWorkouts();
        this.debugInfo += '\nApp mounted';
        
        // Add ids to any existing workouts that don't have them
        this.workouts = this.workouts.map(workout => {
          if (!workout.id) {
            workout.id = Date.now() + Math.floor(Math.random() * 1000);
          }
          if (!workout.type || !this.workoutTypes.includes(workout.type)) {
            workout.type = 'Arms';
          }
          return workout;
        });
        this.saveWorkouts();
      },
      methods: {
        getSortLabel(option) {
          switch(option) {
            case 'alphabetical': return 'Sort: A-Z';
            case 'type': return 'Sort: By Type';
            case 'recent': return 'Sort: Most Recent';
            case 'oldest': return 'Sort: Oldest First';
            default: return 'Sort: A-Z';
          }
        },
        addWorkout() {
          this.debugInfo += `\naddWorkout called: ${this.newWorkoutName}, ${this.newWorkoutType}`;
          
          if (this.newWorkoutName.trim()) {
            const newWorkout = {
              id: Date.now(),
              name: this.newWorkoutName.trim(),
              type: this.newWorkoutType || 'Arms',
              weight: '',
              lastDate: null
            };
            
            this.workouts.push(newWorkout);
            this.newWorkoutName = '';
            this.saveWorkouts();
            
            this.debugInfo += `\nNew workout added: ${JSON.stringify(newWorkout)}`;
          } else {
            this.debugInfo += '\nWorkout name is empty, not adding';
          }
        },
        markWorkoutDone(index) {
          const workout = this.filteredWorkouts[index];
          const actualIndex = this.workouts.findIndex(w => w.id === workout.id);
          
          if (actualIndex !== -1) {
            this.workouts[actualIndex].lastDate = new Date().toISOString();
            this.saveWorkouts();
            this.debugInfo += `\nMarked workout done: ${workout.name}`;
          }
        },
        removeWorkout(index) {
          const workout = this.filteredWorkouts[index];
          
          if (confirm('Are you sure you want to remove this workout?')) {
            const actualIndex = this.workouts.findIndex(w => w.id === workout.id);
            
            if (actualIndex !== -1) {
              this.workouts.splice(actualIndex, 1);
              this.saveWorkouts();
              this.debugInfo += `\nRemoved workout: ${workout.name}`;
            }
          }
        },
        resetFilters() {
          this.filterType = '';
          this.sortOption = 'alphabetical';
          this.debugInfo += '\nFilters reset';
        },
        saveWorkouts() {
          localStorage.setItem('workouts', JSON.stringify(this.workouts));
          this.debugInfo += `\nSaved workouts: ${this.workouts.length} items`;
        },
        loadWorkouts() {
          this.debugInfo += '\nLoading workouts from localStorage';
          const saved = localStorage.getItem('workouts');
          
          if (saved) {
            try {
              this.workouts = JSON.parse(saved);
              this.debugInfo += `\nWorkouts loaded successfully: ${this.workouts.length} items`;
            } catch (e) {
              console.error('Error parsing workouts from localStorage', e);
              this.debugInfo += `\nError parsing workouts: ${e.message}`;
              this.workouts = [];
            }
          } else {
            this.debugInfo += '\nNo saved workouts found';
          }
        },
        formatDate(dateString) {
          const date = new Date(dateString);
          return date.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
          });
        }
      },
      computed: {
        usedWorkoutTypes() {
          // Get an array of workout types that are actually used
          const types = new Set(this.workouts.map(workout => workout.type));
          return this.workoutTypes.filter(type => types.has(type));
        },
        filteredWorkouts() {
          // First filter by type if needed
          let filtered = this.workouts;
          if (this.filterType) {
            filtered = filtered.filter(workout => workout.type === this.filterType);
          }
          
          // Then sort according to the selected option
          return filtered.sort((a, b) => {
            switch (this.sortOption) {
              case 'alphabetical':
                return a.name.localeCompare(b.name);
              
              case 'type':
                // First sort by type, then by name
                if (a.type === b.type) {
                  return a.name.localeCompare(b.name);
                }
                return a.type.localeCompare(b.type);
              
              case 'recent':
                // Put workouts with dates at the top, sorted by most recent
                if (!a.lastDate && !b.lastDate) return 0;
                if (!a.lastDate) return 1;
                if (!b.lastDate) return -1;
                return new Date(b.lastDate) - new Date(a.lastDate);
              
              case 'oldest':
                // Put workouts with dates at the top, sorted by oldest first
                if (!a.lastDate && !b.lastDate) return 0;
                if (!a.lastDate) return 1;
                if (!b.lastDate) return -1;
                return new Date(a.lastDate) - new Date(b.lastDate);
              
              default:
                return 0;
            }
          });
        }
      },
      methods: {
        addWorkout() {
          this.debugInfo += `\naddWorkout called: ${this.newWorkoutName}, ${this.newWorkoutType}`;
          
          if (this.newWorkoutName.trim()) {
            const newWorkout = {
              id: Date.now(),
              name: this.newWorkoutName.trim(),
              type: this.newWorkoutType || 'Arms',
              weight: '',
              lastDate: null
            };
            
            this.workouts.push(newWorkout);
            this.newWorkoutName = '';
            this.saveWorkouts();
            
            this.debugInfo += `\nNew workout added: ${JSON.stringify(newWorkout)}`;
          } else {
            this.debugInfo += '\nWorkout name is empty, not adding';
          }
        },
        markWorkoutDone(index) {
          const workout = this.filteredWorkouts[index];
          const actualIndex = this.workouts.findIndex(w => w.id === workout.id);
          
          if (actualIndex !== -1) {
            this.workouts[actualIndex].lastDate = new Date().toISOString();
            this.saveWorkouts();
            this.debugInfo += `\nMarked workout done: ${workout.name}`;
          }
        },
        removeWorkout(index) {
          const workout = this.filteredWorkouts[index];
          
          if (confirm('Are you sure you want to remove this workout?')) {
            const actualIndex = this.workouts.findIndex(w => w.id === workout.id);
            
            if (actualIndex !== -1) {
              this.workouts.splice(actualIndex, 1);
              this.saveWorkouts();
              this.debugInfo += `\nRemoved workout: ${workout.name}`;
            }
          }
        },
        resetFilters() {
          this.filterType = '';
          this.sortOption = 'alphabetical';
          this.debugInfo += '\nFilters reset';
        },
        saveWorkouts() {
          localStorage.setItem('workouts', JSON.stringify(this.workouts));
          this.debugInfo += `\nSaved workouts: ${this.workouts.length} items`;
        },
        loadWorkouts() {
          this.debugInfo += '\nLoading workouts from localStorage';
          const saved = localStorage.getItem('workouts');
          
          if (saved) {
            try {
              this.workouts = JSON.parse(saved);
              this.debugInfo += `\nWorkouts loaded successfully: ${this.workouts.length} items`;
            } catch (e) {
              console.error('Error parsing workouts from localStorage', e);
              this.debugInfo += `\nError parsing workouts: ${e.message}`;
              this.workouts = [];
            }
          } else {
            this.debugInfo += '\nNo saved workouts found';
          }
        },
        formatDate(dateString) {
          const date = new Date(dateString);
          return date.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
          });
        }
      }
    };
    
    Vue.createApp(app).mount('#app');
  </script>
</body>
</html>